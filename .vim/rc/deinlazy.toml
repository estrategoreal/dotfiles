[[plugins]]
repo = 'basyura/TweetVim'
depends = ['twibill.vim', 'open-browser.vim']
on_cmd = 'TweetVimHomeTimeline'
hook_add = '''
  " Start TweetVim.
  nnoremap <silent> [unite]e :<C-u>Unite tweetvim<CR>
  autocmd MyAutoCmd FileType tweetvim call s:tweetvim_my_settings()
  function! s:tweetvim_my_settings() abort "{{{
    " Open say buffer.
    nnoremap <silent><buffer> s :<C-u>TweetVimSay<CR>
    nnoremap <silent><buffer> q :<C-u>close<CR>
    nmap <silent><buffer> j <Plug>(accelerated_jk_gj)
  endfunction"}}}

  let g:tweetvim_display_separator = 0
'''

[[plugins]]
repo = 'davidhalter/jedi-vim'
if = "!has('nvim')"
on_ft = 'python'
hook_source = '''
  let g:jedi#completions_enabled = 0
  let g:jedi#auto_vim_configuration = 0
  let g:jedi#smart_auto_mappings = 0
  let g:jedi#show_call_signatures = 0
'''

[[plugins]]
repo = 'easymotion/vim-easymotion'
on_map = {n = '<Plug>'}
hook_add = '''
  nmap w <Plug>(easymotion-lineforward)
  nnoremap W w
  nmap b <Plug>(easymotion-linebackward)
  nnoremap B b
  nmap [Alt]j <Plug>(easymotion-j)
  nmap [Alt]k <Plug>(easymotion-k)

  let g:EasyMotion_startofline = 0
  let g:EasyMotion_show_prompt = 0
  let g:EasyMotion_verbose = 0
'''

[[plugins]]
repo = 'fatih/vim-go'
on_ft = 'go'

[[plugins]]
repo = 'fuenor/im_control.vim'
on_if = 1

[[plugins]]
repo = 'h1mesuke/vim-alignta'
on_i = 1
hook_add = '''
  let g:unite_source_alignta_preset_arguments = [
        \ ["Align at '/*' & '*/'", '<-- /* -> */' ],
        \ ["Align at '='", '=>\='],
        \ ["Align at ':'", '01 :'],
        \ ["Align at '|'", '|'   ],
        \ ["Align at ')'", '0 )' ],
        \ ["Align at ']'", '0 ]' ],
        \ ["Align at '}'", '}'   ],
        \]

  xnoremap <silent> [unite]a :<C-u>Unite alignta:arguments<CR>
'''

[[plugins]]
repo = 'hewes/unite-gtags'
on_source = 'unite.vim'

[[plugins]]
repo = 'kana/vim-niceblock'
on_map = {x = '<Plug>'}
hook_add = '''
  xmap I <Plug>(niceblock-I)
  xmap A <Plug>(niceblock-A)
'''

[[plugins]]
repo = 'kana/vim-smartchr'
# on_event = 'InsertCharPre'
on_event = 'InsertEnter'
hook_source = '''
  inoremap <expr> , smartchr#one_of(', ', ',')

  " Smart =.
  inoremap <expr> =
        \ search('\(&\<bar><bar>\<bar>+\<bar>-\<bar>/\<bar>>\<bar><\) \%#', 'bcn')? '<bs>= '
        \ : search('\(*\<bar>!\)\%#', 'bcn') ? '= '
        \ : smartchr#one_of(' = ', ' == ', '=')
  augroup MyAutoCmd
    " Substitute .. into -> .
    autocmd FileType c,cpp inoremap <buffer> <expr> . smartchr#loop('.', '->', '...')
    autocmd FileType vim inoremap <buffer> <expr> . smartchr#loop('.', ' . ', '..', '...')
  augroup END
'''

[[plugins]]
repo = 'kannokanno/previm'
on_cmd = 'PrevimOpen'
depends = 'open-browser.vim'

[[plugins]]
repo = 'LeafCage/foldCC'
on_ft = 'vim'

[[plugins]]
repo = 'lambdalisue/vim-findent'

[[plugins]]
repo = 'majutsushi/tagbar'
on_cmd = 'TagbarOpen'
hook_add = '''
  if IsWindows()
    let g:tagbar_ctags_bin = 'C:/msys64/usr/local/bin/ctags'
  elseif IsMsys() || IsMac()
    let g:tagbar_ctags_bin = '/usr/local/bin/ctags'
  elseif IsFreeBSD()
    let g:tagbar_ctags_bin = '/usr/local/bin/exctags'
  else
    let g:tagbar_ctags_bin = '/usr/bin/ctags'
  endif
  if has('gui_running')
    let g:tabgar_autofocus = 1
    let g:tagbar_width = 42
  endif
  let g:tagbar_sort = 0
'''

[[plugins]]
repo = 'mrtazz/DoxygenToolkit.vim'
on_cmd = 'Dox'
hook_add = '''
  nnoremap <silent> [Space]x :<C-u>Dox<CR>
  let g:load_doxygen_syntax = 1
'''

[[plugins]]
repo = 'osyo-manga/vim-jplus'
on_map = {n = '<Plug>'}
hook_add = '''
  nmap J <Plug>(jplus)
'''

[[plugins]]
repo = 'racer-rust/vim-racer'
on_ft = 'rust'
hook_source = '''
  let $RUST_SRC_PATH = expand('~/.multirust/toolchains/'
  \ .'stable-x86_64-unknown-linux-gnu/'
  \ .'lib/rustlib/src/rust/src/')
'''

[[plugins]]
repo = 'rhysd/accelerated-jk'
on_map = {n = '<Plug>'}
hook_add = '''
  nmap <silent>j <Plug>(accelerated_jk_gj)
  nmap <silent>k <Plug>(accelerated_jk_gk)
'''

[[plugins]]
repo = 'rhysd/vim-operator-surround'
depends = 'vim-operator-user'
on_map = {n = '<Plug>'}
hook_add = '''
  nmap <silent>sa <Plug>(operator-surround-append)a
  nmap <silent>sd <Plug>(operator-surround-delete)a
  nmap <silent>sr <Plug>(operator-surround-replace)a
  nmap <silent>sc <Plug>(operator-surround-replace)a
'''

[[plugins]]
repo = 'rhysd/rust-doc.vim'
on_ft = 'rust'

[[plugins]]
repo = 'rhysd/vim-gfm-syntax'
on_event = 'BufRead'

[[plugins]]
repo = 'rust-lang/rust.vim'
on_ft = 'rust'

[[plugins]]
repo = 'Shougo/context_filetype.vim'

[[plugins]]
repo = 'Shougo/deoplete.nvim'
depends = 'context_filetype.vim'
if = "has('nvim')"
on_i = 1
hook_source = '''
  " Use deoplete.
  let g:deoplete#enable_at_startup = 1

  " Use smartcase.
  let g:deoplete#enable_smart_case = 1

  set completeopt+=noinsert

  " <TAB>: completion.
  inoremap <silent><expr> <TAB>
        \ pumvisible() ? "\<C-n>" :
        \ <SID>check_back_space() ? "\<TAB>" :
        \ deoplete#mappings#manual_complete()
  function! s:check_back_space() abort "{{{
    let col = col('.') - 1
    return !col || getline('.')[col - 1]  =~ '\s'
  endfunction"}}}

  " <S-TAB>: completion back.
  inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

  " <C-h>, <BS>: close popup and delete backword char.
  inoremap <expr><C-h> deoplete#mappings#smart_close_popup()."\<C-h>"
  inoremap <expr><BS> deoplete#mappings#smart_close_popup()."\<C-h>"

  inoremap <expr><C-g> deoplete#mappings#undo_completion()
  " <C-l>: redraw candidates
  inoremap <expr><C-l> deoplete#mappings#refresh()

  " <CR>: close popup and save indent.
  inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
  function! s:my_cr_function() abort
    return deoplete#mappings#close_popup() . "\<CR>"
  endfunction

  inoremap <expr> ' pumvisible() ? deoplete#mappings#close_popup() : "'"

  call deoplete#custom#set('_', 'converters', [
        \ 'converter_remove_paren',
        \ 'converter_remove_overlap',
        \ 'converter_truncate_abbr',
        \ 'converter_truncate_menu',
        \ 'converter_auto_delimiter',
        \ ])

  call deoplete#custom#set('clang', 'input_pattern', '\.\w*|\.->\w*|\w+::\w*')
  call deoplete#custom#set('clang', 'max_pattern_length', -1)

  let g:deoplete#keyword_patterns = {}
  let g:deoplete#keyword_patterns._ = '[a-zA-Z_]\k*\(?'

  let g:deoplete#omni#input_patterns = {}
  let g:deoplete#omni#input_patterns.ruby =
        \ ['[^. *\t]\.\w*', '[a-zA-Z_]\w*::']
  let g:deoplete#omni#input_patterns.python = ''

  let g:deoplete#enable_refresh_always = 1
  let g:deoplete#enable_camel_case = 1

  " deoplete-clang "{{{
  " libclang shared library path
  let g:deoplete#sources#clang#libclang_path = '/usr/lib/libclang.so'

  " clang builtin header path
  let g:deoplete#sources#clang#clang_header = '/usr/include/clang'

  " libclang default compile flags
  let g:deoplete#sources#clang#flags = ['-x', 'c++', '-std=c++11']
  "}}}
'''

[[plugins]]
repo = 'Shougo/neocomplcache.vim'
if = "!has('nvim')"
disabled = "has('lua')"
on_event = 'InsertEnter'
hook_source = '''
  " Use neocomplcache.
  let g:neocomplcache_enable_at_startup = 1

  " Use smartcase.
  let g:neocomplcache_enable_smart_case = 0
  " Use camel case completion.
  let g:neocomplcache_enable_camel_case_completion = 0
  " Use underbar completion.
  let g:neocomplcache_enable_underbar_completion = 0
  " Use fuzzy completion.
  let g:neocomplcache_enable_fuzzy_completion = 1
  " Set minimum syntax keyword length.
  let g:neocomplcache_min_syntax_length = 3
  " Set auto completion length.
  let g:neocomplcache_auto_completion_start_length = 2
  " Set manual completion length.
  let g:neocomplcache_manual_completion_start_length = 0
  " Set minimum keyword length.
  let g:neocomplcache_min_keyword_length = 3

  let g:neocomplcache_enable_auto_close_preview = 1

  if !exists('g:neocomplcache_force_omni_patterns')
    let g:neocomplcache_force_omni_patterns = {}
  endif
  let g:neocomplcache_force_omni_patterns.c =
        \ '[^.[:digit:] *\t]\%(\.\|->\)'
  let g:neocomplcache_force_omni_patterns.cpp =
        \ '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
  let g:neocomplcache_force_omni_patterns.objc =
        \ '[^.[:digit:] *\t]\%(\.\|->\)'

  " Define dictionary.
  let g:neocomplcache_dictionary_filetype_lists = {
        \ 'default' : '',
        \ 'vimshell' : $CACHE .'/.vimshell/command-history'
        \ }

  " Define keyword.
  if !exists('g:neocomplcache_keyword_patterns')
    let g:neocomplcache_keyword_patterns = {}
  endif
  let g:neocomplcache_keyword_patterns['default'] = '[0-9a-zA-Z:#_]\+'
  let g:neocomplete#enable_multibyte_completion = 1

  " <CR>: close popup and save indent.
  inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
  function! s:my_cr_function() abort
    return neocomplcache#smart_close_popup() . "\<CR>"
  endfunction
  " <TAB>: completion.
  inoremap <expr> <TAB> pumvisible() ? "\<C-n>" : "\<TAB>"
  " <C-h>, <BS>: close popup and delete backword char.
  inoremap <expr> <C-h> neocomplcache#smart_close_popup()."\<C-h>"
  inoremap <expr> <BS>  neocomplcache#smart_close_popup()."\<C-h>"
  " <C-y>: paste.
  inoremap <expr> <C-y> pumvisible() ? neocomplcache#close_popup() : "\<C-r>\""
  " <C-e>: close popup.
  inoremap <expr> <C-e> pumvisible() ? neocomplcache#cancel_popup() : "\<End>"

  " AutoComplPop like behavior.
  let g:neocomplcache_enable_auto_select = 1

  " Enable heavy omni completion.
  if !exists('g:neocomplcache_omni_patterns')
    let g:neocomplcache_omni_patterns = {}
  endif
  let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\h\w*\|\h\w*::'
  " let g:neocomplcache_force_omni_patterns.ruby = '[^. *\t]\.\w*\|\h\w*::'
  let g:neocomplcache_force_omni_patterns.python = '[^. \t]\.\w*'
  let g:neocomplcache_omni_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
  let g:neocomplcache_omni_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
'''

[[plugins]]
repo = 'Shougo/neocomplete.vim'
depends = 'context_filetype.vim'
if = "!has('nvim')"
disabled = "!has('lua')"
on_event = 'InsertEnter'
hook_source = '''
  " Use neocomplete.
  let g:neocomplete#enable_at_startup = 1

  " Use smartcase.
  let g:neocomplete#enable_smart_case = 1
  let g:neocomplete#enable_camel_case = 1
  let g:neocomplete#auto_complete_delay = 30
  " Use fuzzy completion.
  let g:neocomplete#enable_fuzzy_completion = 1
  " Set minimum syntax keyword length.
  let g:neocomplete#sources#syntax#min_keyword_length = 3
  " Set auto completion length.
  let g:neocomplete#auto_completion_start_length = 2
  " Set manual completion length.
  let g:neocomplete#manual_completion_start_length = 0
  " Set minimum keyword length.
  let g:neocomplete#min_keyword_length = 3

  " Define dictionary.
  let g:neocomplete#sources#dictionary#directories = {
        \ 'default' : '',
        \ 'vimshell' : $CACHE.'/vimshell/command-history'
        \ }

  " Define keyword.
  if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
  endif
  let g:neocomplete#keyword_patterns._ = '\h\k*(\?'

  " Plugin key-mappings.
  inoremap <expr> <C-g> neocomplete#undo_completion()
  inoremap <expr> <C-l> neocomplete#complete_common_string()

  " <CR>: close popup and save indent.
  inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
  function! s:my_cr_function() abort
    return neocomplete#smart_close_popup() . "\<CR>"
  endfunction
  " <TAB>: completion.
  inoremap <expr> <TAB> pumvisible() ? "\<C-n>" : "\<TAB>"
  " <C-h>, <BS>: close popup and delete backword char.
  inoremap <expr> <C-h> neocomplete#smart_close_popup()."\<C-h>"
  inoremap <expr> <BS>  neocomplete#smart_close_popup()."\<C-h>"
  " <C-y>: paste.
  inoremap <expr> <C-y> pumvisible() ? neocomplete#close_popup() : "\<C-r>\""
  " <C-e>: close popup.
  inoremap <expr> <C-e> pumvisible() ? neocomplete#cancel_popup() : "\<End>"
  " Close popup by <Space>.
  " inoremap <expr><Space> pumvisible() ? "\<C-y>" : "\<Space>"

  " AutoComplPop like behavior.
  let g:neocomplete#enable_auto_select = 1

  " Enable heavy omni completion.
  if !exists('g:neocomplete#sources#omni#input_patterns')
    let g:neocomplete#sources#omni#input_patterns = {}
  endif
  if !exists('g:neocomplete#sources#omni#functions')
    let g:neocomplete#sources#omni#functions = {}
  endif
  if !exists('g:neocomplete#force_omni_input_patterns')
    let g:neocomplete#force_omni_input_patterns = {}
  endif
  let g:neocomplete#enable_auto_close_preview = 1

  let g:neocomplete#sources#omni#input_patterns.c =
        \ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?'
  let g:neocomplete#sources#omni#input_patterns.cpp =
        \ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
  " let g:neocomplete#sources#omni#input_patterns.ruby =
  "       \ '[^. *\t]\.\w*\|\h\w*::\w*'
  let g:neocomplete#sources#omni#input_patterns.python =
        \ '[^. *\t]\.\w*\|\h\w*'
  let g:neocomplete#force_omni_input_patterns.objc =
        \ '\[\h\w*\s\h\?\|\h\w*\%(\.\|->\)'
  let g:neocomplete#force_omni_input_patterns.ruby =
        \ '[^.[:digit:] *\t]\%(\.\|->\)\w*\|\h\w*::\w*'
  let g:neocomplete#sources#omni#functions.go =
        \ 'gocomplete#Complete'
'''

[[plugins]]
repo = 'Shougo/neoinclude.vim'
on_if = 1

[[plugins]]
repo = 'Shougo/neomru.vim'

[[plugins]]
repo = 'Shougo/neosnippet.vim'
depends = ['neosnippet-snippets', 'context_filetype.vim']
# on_event = 'InsertCharPre'
on_event = 'InsertEnter'
on_ft = 'snippet'
hook_source = '''
  imap <C-k> <Plug>(neosnippet_expand_or_jump)
  smap <C-k> <Plug>(neosnippet_expand_or_jump)
  xmap <C-k> <Plug>(neosnippet_expand_target)

  " Enable snipMate compatibility feature.
  let g:neosnippet#enable_snipmate_compatibility = 1
  let g:neosnippet#enable_completed_snippet = 1
  let g:neosnippet#expand_word_boundary = 1

  " let g:snippets_dir = '~/.vim/snippets/,~/.vim/bundle/snipmate/snippets/'
  let g:neosnippet#snippets_directory = '~/.vim/snippets'
'''

[[plugins]]
repo = 'Shougo/neoyank.vim'
on_if = 1
on_event = 'TextYankPost'
on_source = 'unite.vim'

[[plugins]]
repo = 'Shougo/unite.vim'
depends = 'neomru.vim'
hook_source = """
  " Start insert.
  call unite#custom#profile('action', 'context', {
        \ 'start_insert' : 1
        \ })

  " migemo.
  call unite#custom#source('line_migemo', 'matchers', 'matcher_migemo')

  " Keymapping in unite.vim.
  autocmd MyAutoCmd FileType unite call s:unite_my_settings()
  function! s:unite_my_settings() abort "{{{
    call unite#custom#default_action('directory', 'narrow')

    " Overwrite settings.
    nmap <buffer> <ESC>   <Plug>(unite_exit)
    imap <buffer> jj      <Plug>(unite_insert_leave)
    imap <buffer> <C-w>   <Plug>(unite_delete_backward_path)

    imap <buffer><expr> j unite#smart_map('j', '')
    imap <buffer> <TAB>   <Plug>(unite_select_next_line)
    imap <buffer> <C-w>   <Plug>(unite_delete_backward_path)
    imap <buffer> '       <Plug>(unite_quick_match_default_action)
    nmap <buffer> '       <Plug>(unite_quick_match_default_action)
    imap <buffer><expr> x
          \ unite#smart_map('x', "\<Plug>(unite_quick_match_choose_action)")
    nmap <buffer> x       <Plug>(unite_quick_match_choose_action)
    nmap <buffer> <C-z>   <Plug>(unite_toggle_transpose_window)
    imap <buffer> <C-z>   <Plug>(unite_toggle_transpose_window)
    imap <buffer> <C-y>   <Plug>(unite_narrowing_path)
    nmap <buffer> <C-y>   <Plug>(unite_narrowing_path)
    nmap <buffer> <C-j>   <Plug>(unite_toggle_auto_preview)
    nmap <buffer> <C-r>   <Plug>(unite_narrowing_input_history)
    imap <buffer> <C-r>   <Plug>(unite_narrowing_input_history)
    nnoremap <silent><buffer><expr> l
          \ unite#smart_map('l', unite#do_action('default'))
    nnoremap <silent><buffer><expr> P
          \ unite#smart_map('P', unite#do_action('insert'))

    let unite = unite#get_current_unite()
    if unite.buffer_name =~# '^search'
      nnoremap <silent><buffer><expr> r unite#do_action('replace')
    else
      nnoremap <silent><buffer><expr> r unite#do_action('rename')
    endif

    nnoremap <silent><buffer><expr> cd unite#do_action('lcd')
    nnoremap <buffer><expr> S      unite#mappings#set_current_sorters(
          \ empty(unite#mappings#get_current_sorters()) ? ['sorter_reverse'] : [])
    nmap <buffer> x <Plug>(unite_quick_match_jump)
  endfunction"}}}

  let g:unite_enable_auto_select = 0

  if executable('ag')
    " Use ag(the silver searcher)
    " https://github.com/ggreer/the_silver_searcher
    let g:unite_source_grep_command = 'ag'
    let g:unite_source_grep_default_opts =
      \ '-i --vimgrep --hidden --ignore ' .
      \  '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
    let g:unite_source_grep_recursive_opt = ''
  elseif executable('pt')
    " Use pt(the platinum searcher)
    " https://github.com/monochromegane/the_platinum_searcher
    let g:unite_source_grep_command = 'pt'
    let g:unite_source_grep_default_opts = '--nogroup --nocolor'
    let g:unite_source_grep_recursive_opt = ''
    let g:unite_source_grep_encoding = 'utf-8'
  endif

  " For unite-alias.
  let g:unite_source_alias_aliases = {}
  let g:unite_source_alias_aliases.line_migemo = 'line'

  " For unite-menu.
  let g:unite_source_menu_menus = {}

  let g:unite_source_menu_menus.unite = {
        \ 'description' : 'Start unite sources',
        \ }
  let g:unite_source_menu_menus.unite.command_candidates = {
        \ 'directory' : 'Unite -buffer-name=files '.
        \       '-default-action=lcd bookmark directory_mru',
        \ 'history'   : 'Unite history/command',
        \ 'mapping'   : 'Unite mapping',
        \ 'message'   : 'Unite output:message',
        \ 'quickfix'  : 'Unite qflist -no-quit',
        \ 'resume'    : 'Unite -buffer-name=resume resume',
        \ }
  nnoremap <silent> [unite]u :<C-u>Unite menu:unite -resume<CR>

  let s:ext = (IsWindows() ? 'bmp' : 'png')
  let g:unite_build_error_icon    = '~/.vim/signs/err.' . s:ext
  let g:unite_build_warning_icon  = '~/.vim/signs/warn.' . s:ext
"""
hook_add = '''
  " The prefix key.
  nnoremap [unite] <Nop>
  xnoremap [unite] <Nop>
  nmap ; [unite]
  xmap ; [unite]

  nnoremap <silent> [unite]b
        \ :<C-u>Unite -buffer-name=build`tabpagenr()` -no-quit build<CR>
  nnoremap <silent> [unite]c
        \ :<C-u>Unite gtags/context -buffer-name=search -auto-preview -no-quit<CR>
  nnoremap <silent> [unite]d
        \ :<C-u>UniteWithBufferDir -buffer-name=files file file/new<CR>
  nnoremap <silent> [unite]f
        \ :<C-u>Unite buffer file_mru bookmark<CR>
  nnoremap <silent> [unite]j
        \ :<C-u>Unite change jump<CR>
  nnoremap <silent> [unite]o
        \ :<C-u>Unite outline -start-insert -resume<CR>
  nnoremap <silent> [unite]r
        \ :<C-u>Unite -buffer-name=register -default-action=append register history/yank<CR>
  xnoremap <silent> [unite]r
        \ d:<C-u>Unite -buffer-name=register -default-action=append register history/yank<CR>
  nnoremap <silent> [unite]s
        \ :<C-u>Unite source<CR>
  nnoremap <silent> [unite]t
        \ :<C-u>UniteWithCursorWord -buffer-name=tag tag tag/include<CR>
  nnoremap <silent> [Window]s
        \ :<C-u>Unite -buffer-name=files -no-split -multi-line -unique -silent
        \ jump_point file_point buffer_tab:- file_mru
        \ `finddir('.git', ';') != '' ? 'file_rec/git' : ''`
        \ buffer_tab:- file file/new<CR>
  nnoremap <silent> [Window]t
        \ :<C-u>Unite -start-insert tig<CR>
  nnoremap <silent> [Window]w
        \ :<C-u>Unite -force-immediately window:all:no-current<CR>

  nnoremap <silent> [unite]g
        \ :<C-u>Unite grep:. -buffer-name=grep`tabpagenr()` -auto-preview<CR>
  nnoremap <silent> [unite]G
        \ :<C-u>Unite grep:.::`expand('<cword>')` -buffer-name=search -auto-preview<CR>
  xnoremap <silent> [unite]G
        \ :<C-u>call <SID>visual_grep()<CR>
  function! s:visual_grep() abort
    let tmp = @@
    silent normal gvy
    let selected = @@
    let @@ = tmp
    execute 'Unite grep:.::' . selected . ' -buffer-name=search -auto-preview'
  endfunction
  nnoremap <silent> [Space]b :<C-u>UniteBookmarkAdd<CR>

  " t: tags-and-searches "{{{
  " The prefix key.
  nnoremap [Tag] <Nop>
  nmap t [Tag]
  " Jump.
  nnoremap [Tag]t <C-]> zv zz
  " Jump next.
  nnoremap <silent> [Tag]n :<C-u>tnext<CR>
  " Jump previous.
  nnoremap <silent> [Tag]p :<C-u>pop<CR>
  " nnoremap <silent><expr> [Tag]t &filetype == 'help' ?  "g\<C-]>" :
  "       \ ":\<C-u>UniteWithCursorWord -buffer-name=tag -immediately tag tag/include\<CR>"
  " nnoremap <silent><expr> [Tag]p &filetype == 'help' ?
  "       \ ":\<C-u>pop\<CR>" : ":\<C-u>Unite jump\<CR>"
  "}}}

  " Execute help.
  nnoremap <silent> <C-h> :<C-u>Unite -buffer-name=help help<CR>
  " Execute help by cursor keyword.
  nnoremap <silent> g<C-h> :<C-u>UniteWithCursorWord help<CR>
'''

[[plugins]]
repo = 'Shougo/vimfiler.vim'
depends = 'unite.vim'
on_map = {n = '<Plug>'}
on_if = "isdirectory(bufname('%'))"
hook_add = 'nnoremap <silent> <C-g> :<C-u>VimFiler -invisible<CR>'
hook_source = '''
  let g:vimfiler_as_default_explorer = 1

  " Enable file operation commands.
  let g:vimfiler_safe_mode_by_default = 0

  if IsWindows()
    let g:vimfiler_detect_drives = [
          \ 'C:/', 'D:/', 'E:/', 'F:/', 'G:/', 'H:/', 'I:/',
          \ 'J:/', 'K:/', 'L:/', 'M:/', 'N:/']
    " Use trashbox.
    let g:unite_kind_file_use_trashbox = 1
  else
    " Like Textmate icons.
    let g:vimfiler_tree_leaf_icon = ' '
    let g:vimfiler_tree_opened_icon = '▾'
    let g:vimfiler_tree_closed_icon = '▸'
    let g:vimfiler_file_icon = '-'
    let g:vimfiler_readonly_file_icon = '✗'
    let g:vimfiler_marked_file_icon = '✓'
  endif

  autocmd MyAutoCmd FileType vimfiler call s:vimfiler_my_settings()
  function! s:vimfiler_my_settings() abort "{{{
    " Overwrite settings.
    nnoremap <silent><buffer> J
        \ :<C-u>Unite -buffer-name=files -default-action=lcd directory_mru<CR>

    nnoremap <silent><buffer><expr> gy vimfiler#do_action('tabopen')
    nmap <buffer> p <Plug>(vimfiler_quick_look)
    nmap <buffer> <Tab> <Plug>(vimfiler_switch_to_other_window)

    " Migemo search.
    if !empty(unite#get_filters('matcher_migemo'))
    nnoremap <silent><buffer><expr> / line('$') > 10000 ? 'g/' :
            \ ":\<C-u>Unite -buffer-name=search -start-insert line_migemo\<CR>"
    endif
  endfunction"}}}
'''

[[plugins]]
repo = 'Shougo/vimproc.vim'
build = 'make'
on_source = ['unite.vim', 'vimshell.vim']

[[plugins]]
repo = 'Shougo/vimshell.vim'
on_map = {n = '<Plug>'}
hook_add = 'nmap <silent> <C-@> <Plug>(vimshell_switch)'
hook_source = '''
  let g:vimshell_user_prompt = 'fnamemodify(getcwd(), ":~")'
  let g:vimshell_right_prompt =
         \ 'gita#statusline#format("%{|/}ln%lb%{ <> |}rn%{/|}rb")'
  let g:vimshell_prompt = '% '
  let g:vimshell_split_command = ''
  let g:vimshell_enable_transient_user_prompt = 1
  let g:vimshell_force_overwrite_statusline = 1

  autocmd MyAutoCmd FileType vimshell call s:vimshell_settings()
  function! s:vimshell_settings() abort "{{{
    if !IsWindows()
      " Use zsh history.
      let g:vimshell_external_history_path = expand('~/.zsh_history')
    endif

    " Initialize execute file list.
    let g:vimshell_execute_file_list = {}
    call vimshell#set_execute_file('txt,vim,c,h,cpp', 'vim')
    let g:vimshell_execute_file_list['py'] = 'python'
    let g:vimshell_execute_file_list['rb'] = 'ruby'

    " Hide the window in hitting ESC key twice.
    nmap <silent><buffer> <ESC><ESC> <C-^>
    imap <silent><buffer> <ESC><ESC> <ESC><C-^>
    imap <buffer><BS>  <Plug>(vimshell_another_delete_backward_char)
    imap <buffer><C-h> <Plug>(vimshell_another_delete_backward_char)
    imap <buffer><C-k> <Plug>(vimshell_zsh_complete)
    imap <buffer><C-g> <Plug>(vimshell_history_neocomplete)

    xmap <buffer> y <Plug>(operator-concealedyank)

    nnoremap <silent><buffer> <C-j>
          \ :<C-u>Unite -buffer-name=files
          \ -default-action=lcd directory_mru<CR>

    call vimshell#set_alias('ll', 'ls -l')
    call vimshell#set_alias('la', 'ls -alF')
    call vimshell#set_alias('l', 'ls -CF')
    call vimshell#set_alias('l.', 'ls -d .*')
    call vimshell#set_alias('cp', 'cp -i')
    call vimshell#set_alias('rm', 'rm -i')
    call vimshell#set_alias('mv', 'mv -i')
  endfunction"}}}
'''

[[plugins]]
repo = 'Shougo/vinarise.vim'
on_cmd = 'Vinarise'
hook_add = '''
    let g:vinarise_enable_auto_detect = 1
'''

[[plugins]]
repo = 'thinca/vim-qfreplace'
on_ft = ['unite', 'qf']
hook_add = '''
  autocmd MyAutoCmd FileType qf nnoremap <buffer> r :<C-u>Qfreplace<CR>
'''

[[plugins]]
repo = 'thinca/vim-ref'
on_map = {n = '<Plug>'}
hook_source = '''
  let g:ref_cache_dir = expand('$CACHE/ref')
  let g:ref_use_vimproc = 1
  if IsWindows()
    let g:ref_refe_encoding = 'cp932'
  endif

  autocmd MyAutoCmd FileType ref call s:ref_my_settings()
  function! s:ref_my_settings() abort "{{{
    " Overwrite settings.
    nmap <buffer> [Tag]t <Plug>(ref-keyword)
    nmap <buffer> [Tag]p <Plug>(ref-back)
    nnoremap <buffer> <TAB> <C-w>w
  endfunction"}}}
'''

[[plugins]]
repo = 'todesking/ruby_hl_lvar.vim'
on_ft = 'ruby'

[[plugins]]
repo = 'tweekmonster/impsort.vim'
on_cmd = 'ImpSort'
hook_source = 'let g:impsort_highlight_imported = 0'

[[plugins]]
repo = 'tyru/caw.vim'
on_map = {nx = '<Plug>'}
hook_add = '''
  function! InitCaw() abort
    if !&l:modifiable
      silent! nunmap <buffer> gc
      silent! xunmap <buffer> gc
      silent! nunmap <buffer> gcc
      silent! xunmap <buffer> gcc
    else
      nmap <buffer> gc <Plug>(caw:prefix)
      xmap <buffer> gc <Plug>(caw:prefix)
      nmap <buffer> gcc <Plug>(caw:hatpos:toggle)
      xmap <buffer> gcc <Plug>(caw:hatpos:toggle)
    endif
  endfunction
  autocmd MyAutoCmd FileType * call InitCaw()
  call InitCaw()
'''

[[plugins]]
repo = 'tyru/open-browser.vim'

[[plugins]]
repo = 'yuratomo/w3m.vim'
on_cmd = 'W3mTab'
hook_add = '''
  nnoremap [Alt]w :<C-u>W3mTab<Space>
  if IsWindows() || IsMsys()
    let g:w3m#external_browser = 'C:/Program\ Files\ (x86)/Google/Chrome/Application/chrome.exe'
  elseif IsMac()
    let g:w3m#external_browser = 'open -a "Google Chrome"'
  elseif IsFreeBSD()
    let g:w3m#external_browser = 'chrome'
  else
    let g:w3m#external_browser = 'chromium'
  endif
  " let g:w3m#search_engine = 'https://www.google.co.jp/search?ie=' . &encoding . '&q=%s'
  let g:w3m#search_engine = 'https://www.google.co.jp/search?q=%s'
  autocmd MyAutoCmd FileType w3m call s:w3m_settings()
  function! s:w3m_settings() abort
    nnoremap <buffer> H :<C-u>call w3m#Back()<CR>
    nnoremap <buffer> L :<C-u>call w3m#Forward()<CR>
    nnoremap <buffer> E :<C-u>W3mShowExtenalBrowser<CR>
    nnoremap <buffer> Q :<C-u>W3mClose<CR>
  endfunction
'''

[[plugins]]
repo = 'tweekmonster/deoplete-clang2'
if = "has('nvim')"
on_ft = ['c', 'cpp']
hook_source = '''
  autocmd FileType c,cpp let b:clang2_orig_maps = {}
'''

[[plugins]]
repo = 'zchee/deoplete-jedi'
if = "has('nvim')"
on_ft = 'python'

[[plugins]]
repo = 'zchee/deoplete-go'
if = "has('nvim')"
on_i = 1
on_ft = 'go'

[[plugins]]
repo = 'zchee/deoplete-zsh'
if = "has('nvim')"
on_ft = 'zsh'

